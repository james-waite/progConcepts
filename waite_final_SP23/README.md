So this thing should look familiar by now, haha. I first attempted to implement shaders for my shapes. Other than then difficulty in learning/parseing shaders, which is based on C++, I also couldn't get it implemented. My first difficulty was that you had to be in WebGL mode for the canvas, which in turn 'broke' my drawShapes.js function. I fixed this by using a createGraphic (seen in the code as sg. for 'shapeGraphic'), and drew the shape to the createGraphic and displayed that as an image. However, because I'm removing the vertex information from the WebGL context to a 2D context, theres an issue now with miscommunication with the shaders... I think? I'm truly lost on this one, so after spending a week and a half trying to figure it out I moved on (link to the shader resource I used: https://github.com/aferriss/p5jsShaderExamples).

Next, I visited the easing functions, to add more dynamic animations to the lerp() function rather than a linear tween in .01 steps every frame. I found these resources to be helpful: https://gizma.com/easing/#quad3 https://gist.github.com/gre/1650294. While I was able to get the quadratic easing functions 'working' they produced undesired results. There's definitely something wrong with my understanding of incrementing time and managing that in framerate. I tried to do something along the lines of taking the total duration, in milliseconds (e.g. 4000 --> 4 seconds), subtracting that by p5's deltaTime (elapsed time in milliseconds since last frame, usually 19-22 milliseconds) then using that to divide a frame count that I reset after every successful state change. Using that value, I would multiply that by the lerpAmount (0.1) and add that to the previous value of the lerpValue, or what percentage between shape states need to be lerp() this frame. It... kinda works? I'm definitely having a hard time wrapping my head around this, but I got the different easing functions included as switch cases handled by radio buttons. I also added a 'pause' feature that simply returns and ends the draw loop if the mouse is held down. Simple but effective. At least one feature was included that works...
